<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Récupération données</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; padding:16px; background:#0b1220; color:#e5e7eb;}
    h1{font-size:18px;margin:0 0 12px}
    button{padding:10px 12px;border:0;border-radius:10px;margin:6px 6px 6px 0;cursor:pointer}
    .row{margin:10px 0}
    textarea{width:100%;height:45vh;border-radius:12px;border:1px solid #334155;background:#0f172a;color:#e5e7eb;padding:10px;box-sizing:border-box}
    .small{opacity:.8;font-size:12px;line-height:1.4}
    .ok{color:#22c55e}
    .warn{color:#f59e0b}
  </style>
</head>
<body>
  <h1>Récupération des données locales</h1>
  <div class="small">
    Ne désinstalle pas la PWA, ne vide pas Safari. Cette page lit <b>localStorage</b> et tente <b>IndexedDB</b>.
  </div>

  <div class="row">
    <button id="dumpLS">Exporter localStorage</button>
    <button id="dumpIDB">Tenter export IndexedDB</button>
    <button id="copy">Copier JSON</button>
    <button id="download">Télécharger JSON</button>
  </div>

  <div class="row small">
    <div id="status" class="warn">En attente…</div>
  </div>

  <textarea id="out" placeholder="Le JSON apparaîtra ici…"></textarea>

<script>
(async () => {
  const status = (msg, ok=false) => {
    const el = document.getElementById('status');
    el.textContent = msg;
    el.className = ok ? 'ok' : 'warn';
  };

  // 1) Limiter les effets de cache
  try {
    if ('serviceWorker' in navigator) {
      const regs = await navigator.serviceWorker.getRegistrations();
      for (const r of regs) await r.unregister();
    }
    if ('caches' in window) {
      const keys = await caches.keys();
      for (const k of keys) await caches.delete(k);
    }
    status("Service Worker/cache nettoyés (sans toucher au stockage).", true);
  } catch (e) {
    status("Impossible de nettoyer SW/cache (pas grave).");
  }

  const outEl = document.getElementById('out');

  function getLocalStorageDump() {
    const obj = {};
    for (let i=0; i<localStorage.length; i++) {
      const k = localStorage.key(i);
      obj[k] = localStorage.getItem(k);
    }
    return obj;
  }

  async function tryDumpIndexedDB() {
    // Safari récent peut supporter indexedDB.databases()
    const result = {};
    if (!window.indexedDB) {
      result.__error = "indexedDB non disponible";
      return result;
    }

    if (typeof indexedDB.databases !== 'function') {
      result.__info = "indexedDB.databases() non supporté sur cet iPhone/iOS. Il faudra connaître le nom de la DB.";
      return result;
    }

    const dbs = await indexedDB.databases();
    result.__databases = dbs.map(d => ({name: d.name, version: d.version}));
    // On ne peut pas lister automatiquement les objectStores sans ouvrir chaque DB avec sa version.
    // On tente une ouverture “best effort” et on liste les stores via l’événement onupgradeneeded? Non.
    // Donc: on ouvre sans upgrade et on lit les stores listés dans db.objectStoreNames.
    for (const d of dbs) {
      if (!d.name) continue;
      result[d.name] = await new Promise((resolve) => {
        const req = indexedDB.open(d.name);
        req.onerror = () => resolve({__error: "open error"});
        req.onsuccess = () => {
          const db = req.result;
          const stores = Array.from(db.objectStoreNames || []);
          const dbDump = {__stores: stores, data: {}};

          if (stores.length === 0) { db.close(); return resolve(dbDump); }

          // On lit store par store
          let pending = stores.length;
          const tx = db.transaction(stores, 'readonly');
          tx.oncomplete = () => { db.close(); resolve(dbDump); };
          tx.onerror = () => { db.close(); resolve({...dbDump, __error:"tx error"}); };

          for (const s of stores) {
            try {
              const store = tx.objectStore(s);
              const getAll = store.getAll ? store.getAll() : null;
              if (getAll) {
                getAll.onsuccess = () => { dbDump.data[s] = getAll.result; if(--pending===0){} };
                getAll.onerror = () => { dbDump.data[s] = {__error:"getAll error"}; if(--pending===0){} };
              } else {
                // Fallback curseur si getAll absent
                const items = [];
                const cur = store.openCursor();
                cur.onsuccess = (ev) => {
                  const c = ev.target.result;
                  if (c) { items.push({key:c.key, value:c.value}); c.continue(); }
                  else { dbDump.data[s] = items; if(--pending===0){} }
                };
                cur.onerror = () => { dbDump.data[s] = {__error:"cursor error"}; if(--pending===0){} };
              }
            } catch(e) {
              dbDump.data[s] = {__error: String(e)};
              pending--;
            }
          }
        };
      });
    }
    return result;
  }

  function setOutput(obj) {
    outEl.value = JSON.stringify(obj, null, 2);
  }

  document.getElementById('dumpLS').onclick = () => {
    const payload = {
      exportedAt: new Date().toISOString(),
      type: "localStorage",
      origin: location.origin,
      data: getLocalStorageDump()
    };
    setOutput(payload);
    status("localStorage exporté ✅", true);
  };

  document.getElementById('dumpIDB').onclick = async () => {
    status("Extraction IndexedDB en cours…");
    const idb = await tryDumpIndexedDB();
    const payload = {
      exportedAt: new Date().toISOString(),
      type: "indexedDB",
      origin: location.origin,
      data: idb
    };
    setOutput(payload);
    status("Tentative IndexedDB terminée ✅ (regarde le JSON)", true);
  };

  document.getElementById('copy').onclick = async () => {
    try {
      await navigator.clipboard.writeText(outEl.value || "");
      status("JSON copié ✅", true);
    } catch(e) {
      status("Copie impossible sur iOS (essaie de sélectionner manuellement).");
    }
  };

  document.getElementById('download').onclick = () => {
    const blob = new Blob([outEl.value || ""], {type:"application/json"});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `shiftly-export-${Date.now()}.json`;
    a.click();
    setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
    status("Fichier JSON téléchargé ✅", true);
  };
})();
</script>
</body>
</html>
